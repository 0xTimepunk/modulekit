// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.25;

import { ERC7579HookBase, ERC7579ExecutorBase } from "modulekit/src/Modules.sol";
import { ERC7579HookBaseNew } from "modulekit/src/modules/ERC7579HookBaseNew.sol";
import { SENTINEL, SentinelListLib } from "sentinellist/SentinelList.sol";
import { IERC7579Account, Execution } from "modulekit/src/Accounts.sol";
import { ModeLib } from "erc7579/lib/ModeLib.sol";
import { ExecutionLib } from "erc7579/lib/ExecutionLib.sol";
import { IERC7484 } from "modulekit/src/interfaces/IERC7484.sol";
import { IERC7579Hook } from "modulekit/src/external/ERC7579.sol";
import { HookMultiPlexerLib } from "./HookMultiPlexerLib.sol";

contract HookMultiPlexer is ERC7579HookBase, ERC7579ExecutorBase {
    using SentinelListLib for SentinelListLib.SentinelList;
    using HookMultiPlexerLib for IERC7579Hook;

    /*//////////////////////////////////////////////////////////////////////////
                            CONSTANTS & STORAGE
    //////////////////////////////////////////////////////////////////////////*/

    error NoHookRegistered(address smartAccount);
    error HookReverted(address hookAddress, bytes hookData);
    error InvalidHookInitDataLength();

    struct Config {
        IERC7579Hook[] globalHooks;
        mapping(bytes4 => IERC7579Hook[]) sigHooks;
        mapping(bytes4 => IERC7579Hook[]) targetSigHooks;
        IERC7579Hook[] valueHooks;
    }

    mapping(address account => Config) config;

    /*//////////////////////////////////////////////////////////////////////////
                                    CONSTRUCTOR
    //////////////////////////////////////////////////////////////////////////*/

    IERC7484 public immutable REGISTRY;

    constructor(IERC7484 _registry) {
        REGISTRY = _registry;
    }

    /*//////////////////////////////////////////////////////////////////////////
                                     CONFIG
    //////////////////////////////////////////////////////////////////////////*/

    function onInstall(bytes calldata data) external {
        // TODO
    }

    function onUninstall(bytes calldata) external override {
        // TODO
    }

    function isInitialized(address smartAccount) public view returns (bool) {
        // TODO: this is a temporary solution
        return config[smartAccount].globalHooks.length != 0;
    }

    /*//////////////////////////////////////////////////////////////////////////
                                     MODULE LOGIC
    //////////////////////////////////////////////////////////////////////////*/

    function preCheck(
        address msgSender,
        uint256 msgValue,
        bytes calldata msgData
    )
        external
        returns (bytes memory hookReturnData)
    {
        IERC7579Hook[] memory hooks =
            _getHooks(msg.sender, bytes4(msgData[0:4]), _getTargetSig(msgData), msgValue > 0);
        uint256 hooksLength = hooks.length;

        bytes[] memory hookReturnDataArray = new bytes[](hooksLength);

        for (uint256 i = 0; i < hooksLength; i++) {
            IERC7579Hook subHook = hooks[i];
            hookReturnDataArray[i] = subHook.preCheckSubHook({
                msgSender: msgSender,
                msgValue: msgValue,
                msgData: msgData
            });
        }

        hookReturnData = abi.encodePacked(
            bytes4(msgData[0:4]),
            _getTargetSig(msgData),
            msgValue > 0,
            abi.encode(hookReturnDataArray)
        );
    }

    function postCheck(bytes calldata preCheckContext) external {
        bytes4 sig = bytes4(preCheckContext[0:4]);
        bytes4 targetSig = bytes4(preCheckContext[4:8]);
        bool hasValue = preCheckContext[8] == 1;
        bytes[] memory hookReturnDataArray = abi.decode(preCheckContext[9:], (bytes[]));

        IERC7579Hook[] memory hooks = _getHooks(msg.sender, sig, targetSig, hasValue);
        uint256 hooksLength = hooks.length;

        for (uint256 i = 0; i < hooksLength; i++) {
            IERC7579Hook subHook = hooks[i];
            subHook.postCheckSubHook(hookReturnDataArray[i]);
        }
    }

    /*//////////////////////////////////////////////////////////////////////////
                                     INTERNAL
    //////////////////////////////////////////////////////////////////////////*/

    function _getTargetSig(bytes calldata msgData) internal pure returns (bytes4) {
        return bytes4(msgData[0:4]);
    }

    function _getHooks(
        address account,
        bytes4 sig,
        bytes4 targetSig,
        bool hasValue
    )
        internal
        returns (IERC7579Hook[] memory)
    {
        IERC7579Hook[] memory globals = config[account].globalHooks;
        IERC7579Hook[] memory sigHooks = config[account].sigHooks[sig];
        IERC7579Hook[] memory targetSigHooks = config[account].targetSigHooks[targetSig];

        IERC7579Hook[] memory valueHooks;
        if (hasValue) {
            valueHooks = config[account].valueHooks;
        }

        uint256 hooksLength =
            globals.length + sigHooks.length + targetSigHooks.length + valueHooks.length;

        IERC7579Hook[] memory hooks = new IERC7579Hook[](hooksLength);

        // this needs to be optimized
        uint256 index = 0;
        for (uint256 i = 0; i < globals.length; i++) {
            hooks[index++] = globals[i];
        }

        for (uint256 i = 0; i < sigHooks.length; i++) {
            hooks[index++] = sigHooks[i];
        }

        for (uint256 i = 0; i < targetSigHooks.length; i++) {
            hooks[index++] = targetSigHooks[i];
        }

        for (uint256 i = 0; i < valueHooks.length; i++) {
            hooks[index++] = valueHooks[i];
        }

        return hooks;
    }

    /*//////////////////////////////////////////////////////////////////////////
                                     METADATA
    //////////////////////////////////////////////////////////////////////////*/

    function name() external pure returns (string memory) {
        return "HookMultiPlexer";
    }

    function version() external pure returns (string memory) {
        return "1.0.0";
    }

    function isModuleType(uint256 typeID) external pure override returns (bool) {
        return typeID == TYPE_HOOK || typeID == TYPE_EXECUTOR;
    }
}
