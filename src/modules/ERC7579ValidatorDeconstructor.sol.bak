// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "./ERC7579ValidatorBase.sol";
import "./utils/ERC7579ValidatorLib.sol";

struct ValidationSub {
    uint48 validUntil;
    uint48 validAfter;
}

abstract contract ValidatorDeconstructor is ERC7579ValidatorBase {
    using ERC7579ValidatorLib for UserOperation;
    using ERC7579ValidatorLib for bytes;

    error InvalidExecutionType();

    function validate(
        UserOperation calldata userOp,
        function(address,address,uint,bytes calldata) internal returns(ValidationSub memory)
            validationFunction,
        function(ValidationSub[] memory) internal pure returns(ValidationData) returnValidationData
    )
        external
        view
        virtual
        returns (ValidationSub[] memory subs)
    {
        ACCOUNT_EXEC_TYPE _type = userOp.decodeExecType();

        address smartAccount = userOp.sender();
        address target;
        uint256 value;
        bytes calldata callData;

        if (ACCOUNT_EXEC_TYPE.EXEC_SINGLE == _type) {
            (target, value, callData) = userOp.decodeCalldataSingle();
            subs = new ValidationSub[](1);
            subs[0] = validationFunction(smartAccount, target, value, callData);
        } else if (ACCOUNT_EXEC_TYPE.EXEC_BATCH == _type) {
            IERC7579Execution.Execution[] calldata executionBatch = userOp.decodeCalldataBatch();
            uint256 length = executionBatch.length;
            ValidationSub[] memory result = new ValidationSub[](length);
            for (uint256 i; i < length; i++) {
                IERC7579Execution.Execution calldata execution = executionBatch[i];
                result[i] = validationFunction(
                    smartAccount, execution.target, execution.value, execution.data
                );
            }
            return result;
        } else {
            revert InvalidExecutionType();
        }
    }

    function returnLatestValidationData(ValidationSub[] memory subs)
        internal
        pure
        returns (ValidationData)
    {
        uint256 length = subs.length;
        uint256 result;
        for (uint256 i; i < length; i++) {
            ValidationSub memory sub = subs[i];
            result = _packValidationData(false, sub.validUntil, sub.validAfter);
        }
        return ValidationData.wrap(result);
    }
}
